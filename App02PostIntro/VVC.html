{{ extends 'global/Page.html' }}
{{ block title }} Virtual Video Call{{ endblock }}
{{ block content }}

<style>
    .column {
        float: left;
        height: 80vh; /* Responsive height */
        box-sizing: border-box;
    }
    .left {
        width: 70%;
    }
    .right {
        width: 30%;
        vertical-align: middle;
        border: 1px solid #000;
    }

    /* Row style with maximum width and responsive adjustments */
    .row {
        width: 100%;
        max-width: 1200px;
        margin: 0 auto; /* Center align the row */
    }

    /* Clear floats after the columns */
    .row:after {
        content: "";
        display: table;
        clear: both;
    }
    #meet {
        width: 100%;
        height: 80vh; /* Set the height to 100% of the viewport height */
    }
    .my-box {
        border: 1px solid #ccc;
        padding: 10px;
        background-color: #f9f9f9;
    }
    #displaymessage {
        display: none;
    }

    #progressBarContainer {
        width: 100%;
        background-color: #f3f3f3;
        border: 1px solid #ccc;
        margin-top: 20px;
        display: none;
    }

    #progressBar {
        width: 0;
        height: 30px;
        background-color: #4caf50;
        text-align: center;
        line-height: 30px;
        color: white;
    }

    /* Responsive layout */
    @media (max-width: 1200px) {
        .row {
            max-width: 1000px;
        }
    }

    @media (max-width: 1000px) {
        .row {
            max-width: 800px;
        }
    }

    @media (max-width: 800px) {
        .row {
            max-width: 600px;
        }
    }

    @media (max-width: 600px) {
        .row {
            max-width: 100%;
        }

        .column {
            float: none;
            width: 100%;
            height: 80vh; /* Adjust height to auto for small screens */
        }

        .left, .right {
            width: 100%;
        }

        .right {
            margin-top: 20px;
            border: none;
        }
    }

</style>
<div class="my-box">
    <div id="message"><p><b>The video meeting will last for 15 minutes.
        After 15 minutes, you will be automatically redirected to the next page.</b>
    </p></div>
    <div id="videopanel" class="row">
        <div class="column left">
            <div id="meet"></div>
        </div>
        <div id="container" class="column right"></div>
    </div>
    <div id="progressBarContainer" style="display:none;">
        <div id="progressBar">0%</div>
    </div>
    <div id="nextButtonContainer" style="display:none;">
        <button id="nextButton">Next</button>
    </div>
     <input id="duration" type="hidden" name="video_duration" value="0.0"/>
</div>
<br/>

<script src="https://haps-meeting.k8s.iism.kit.edu/external_api.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/highcharts-more.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>

<script>
    const domain = "haps-meeting.k8s.iism.kit.edu"; //Here goes your domain where the meeting takes place.
    const NameParam = {{player.id_in_group}} % 4;
    const TN_name = "P" + {{player.id_in_group}};
    // adjust information to display

    const options = {
        roomName: "Video Meeting" + {{player.group_id}}, //This is the name of the room, with player's group ID
        parentNode: document.querySelector('#meet'), //Now, you declare here which element should parent your stream.
        configOverwrite: {
            prejoinConfig: {
                enabled: false
            },
            disableSelfView: false,
            startWithAudioMuted: false,
            startWithVideoMuted: false,
            filmstrip: {
                disableResizable: true,
            },
            participantsPane: {
                hideModeratorSettingsTab: false,
                hideMoreActionsButton: false,
                hideMuteAllButton: false
            },
            resolution: 480,
                constraints: {
                    video: {
                        height: {
                            ideal: 480,
                            max: 480,
                            min: 240
                        }
                    }
                },
                disableSimulcast: false,
                enableLayerSuspension: true
        },
        interfaceConfigOverwrite: {
            TOOLBAR_BUTTONS: [],
            SHOW_JITSI_WATERMARK: false,
            TILE_VIEW_MAX_COLUMNS: 2,
            TILE_VIEW_ENABLED: true,
            SHOW_MEETING_TIMER: false
        },
        userInfo: {
            displayName: TN_name,
        }
    };
    const api = new JitsiMeetExternalAPI(domain, options); //This is where the iframe is actually constructed
    //The function below turns on the Tile View everytime a participant joins. Practically it makes Tile View the default mode
    api.addEventListener('videoConferenceJoined', () => {
        api.executeCommand('setTileView', true);
    });

    let mediaRecorder;
    let recordedChunks = [];
    let stream;

    document.addEventListener('DOMContentLoaded', async function () {
        let remoteServerURL = 'https://kithumansubjectsstudy.org:3000/upload/video/noOptIn';
        {% if participant.vars.optInConsent == 0 %}
            remoteServerURL = 'https://kithumansubjectsstudy.org:3000/upload/video/noOptIn';
        {% else %}
            remoteServerURL = 'https://kithumansubjectsstudy.org:3000/upload/video/optIn';
        {% endif %}
        let recordedChunks = [];
        let mediaRecorder;
        let stream;
        const formData = new FormData();

        try {
            console.log('Requesting display media...');
            stream = await navigator.mediaDevices.getDisplayMedia({
                      preferCurrentTab: true,
            	      video: {
                         mediaSource: 'tab',
                         frameRate: { max: 10 },
                         width: { max: 1024 },
                         height: { max: 768 }
                       },
                       audio: true
            });

            console.log('Media stream obtained.');

            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                    console.log('Data available:', event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                console.log('Media recorder stopped.');

                // Create a Blob from the recorded chunks
                const blob = new Blob(recordedChunks, { type: 'video/webm' });

                const timestamp = new Date().toISOString().replace(/[-:.]/g, '');
                const groupId = '{{ group.id_in_subsession }}';
                const playerId = '{{ player.id_in_group }}';
                const filenameWebm = `recording_${groupId}_${playerId}.webm`;

                // Append the webm file to formData
                formData.append('video', blob, filenameWebm);
                console.log('Form data prepared for upload.');

               /* // Calculate video duration using ffmpeg
                const { createFFmpeg, fetchFile } = FFmpeg;
                const ffmpeg = createFFmpeg({ log: true });
                await ffmpeg.load();
                ffmpeg.FS('writeFile', filenameWebm, await fetchFile(blob));
                await ffmpeg.run('-i', filenameWebm, '-hide_banner');
                const durationOutput = ffmpeg.FS('readFile', 'stdout');
                const durationMatch = durationOutput.toString().match(/Duration: (\d+):(\d+):(\d+).(\d+)/);
                let totalDuration = 0;
                if (durationMatch) {
                    const hours = parseInt(durationMatch[1], 10);
                    const minutes = parseInt(durationMatch[2], 10);
                    const seconds = parseInt(durationMatch[3], 10);
                    const milliseconds = parseInt(durationMatch[4], 10);
                    totalDuration = (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
                    console.log('Video Duration:', totalDuration, 'seconds');
                }

                    var duration = document.getElementById("duration");
                    duration.value = totalDuration;*/

                // Store the total duration in an oTree variable


                // Upload the video
               let uploadUrl = 'https://kithumansubjectsstudy.org:3000/upload/video/noOptIn';
                {% if participant.vars.optInConsent == 0 %}
                    uploadUrl = 'https://kithumansubjectsstudy.org:3000/upload/video/noOptIn';
                {% else %}
                    uploadUrl = 'https://kithumansubjectsstudy.org:3000/upload/video/optIn';
                {% endif %}

                try {
                    const response = await fetch(uploadUrl, {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        console.log('Video uploaded successfully.');
                        alert('Video uploaded successfully.');
                    } else {
                        console.error('Failed to upload video.');
                        alert('Failed to upload video.');
                    }
                } catch (error) {
                    console.error('Error uploading video:', error);
                }
            };

            mediaRecorder.start();
            console.log('Media recorder started.');

            // Stop recording after 15 minutes
            $('.otree-timer__time-left').on('update.countdown', function (event) {
                if (event.offset.totalSeconds === 61) {
                    mediaRecorder.stop();
                    stream.getTracks().forEach(track => track.stop());
		    api.dispose();
  		    document.getElementById('message').innerHTML = '<p><b>Please wait briefly while the upload completes.</b></p>';
                    
                  }
            });
        } catch (err) {
            console.error('Error accessing display media.', err);
        }
    });
</script>
{{ endblock }}
